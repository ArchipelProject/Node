#!/bin/bash
#
# ovirt-early Start early ovirt services
#
# chkconfig: - 01 99
# description: ovirt-early services
#

# Source functions library
. /etc/init.d/functions
. /etc/init.d/ovirt-functions

BONDING_MODCONF_FILE=/etc/modprobe.d/bonding
AUGTOOL_CONFIG=/var/tmp/augtool-config

get_mac_addresses() {
    macs=$(ifconfig | awk '/HWaddr/ { print $5"="$1 }' \
                    | tr '\n' ' ' | sed 's/ /%2C/g;s/:/%3A/g')
}

configure_from_network() {
    DEVICE=$1
    if [ -n "$DEVICE" ]; then
        echo "Configuring network Using interface $DEVICE"
        # setup temporary interface to retrieve configuration
        echo "network --device $DEVICE --bootproto dhcp" | nash
        if [ $? -eq 0 ]; then
            # from network-scripts/ifup-post
            IPADDR=$(LC_ALL=C ip -o -4 addr ls dev ${DEVICE} | awk '{ print $4 ; exit }')
            echo "Interface brought up with $IPADDR"
            eval $(ipcalc --silent --hostname ${IPADDR} ; echo "status=$?")
            if [ "$status" = "0" ]; then
                hostname $HOSTNAME
                echo "Hostname resolved to $HOSTNAME"
                # retrieve remote config
                find_srv ovirt tcp
                if [ -n "$SRV_HOST" -a -n "$SRV_PORT" ]; then
                    echo "oVirt Server found at: $SRV_HOST:$SRV_PORT"
                    cfgdb=$(mktemp)
                    get_mac_addresses
                    echo "MACs to use: $macs"
                    wget -O $cfgdb \
                      "http://$SRV_HOST:$SRV_PORT/ovirt/managed_node/config?host=$(hostname)&macs=$macs"
                    if [ $? -eq 0 ]; then
                        echo "Remote configuration bundle retrieved to $cfgdb"
                        ovirt-process-config $cfgdb $BONDING_MODCONF_FILE $AUGTOOL_CONFIG
			if [ $? -eq 0 ]; then
			    echo "Remote configuration retrieved and applied"
			else
			    echo "Failure to retrieve or apply remote configuration"
			fi
                    else
                        echo "Failed to retrieve configuration bundle"
                    fi
                    rm $cfgdb
                fi
            fi
        fi
    fi
    # default oVirt network configuration:
    # bridge each ethernet device in the system
    ETHDEVS=$(cd /sys/class/net && ls -d eth*)
    for eth in $ETHDEVS; do
        BRIDGE=ovirtbr`echo $eth | cut -b4-`
        echo "Applying default configuration to $eth and $BRIDGE"
        printf '%s\n' "DEVICE=$eth" ONBOOT=yes "BRIDGE=$BRIDGE" \
            > /etc/sysconfig/network-scripts/ifcfg-$eth
        printf '%s\n' "DEVICE=$BRIDGE" BOOTPROTO=dhcp \
            ONBOOT=yes TYPE=Bridge PEERNTP=yes DELAY=0 \
            > /etc/sysconfig/network-scripts/ifcfg-$BRIDGE
    done
    echo "Default config applied"
}

# $(get_live_disk)
# livecd boot disk
get_live_disk() {
    local live_dev=/dev/live
    if [ ! -e $live_dev ]; then
      # PXE boot
      live_dev=/dev/loop0
      live_disk=
    else
      live_part=$(readlink -e $live_dev)
      live_disk=$(basename $(dirname $(udev_info $live_part path)))
    fi
    echo $live_disk
}

# find_disk $bus $serial
find_disk() {
    local bus=$1
    local serial=$2
    local live=$(get_live_disk)
    for d in /dev/disk/by-id/{scsi,usb}*; do
      ID_FS_USAGE=
      eval $(udev_info $d env)
      # ID_FS_USAGE is set for partitions
      if [ -z "$ID_FS_USAGE" -a "$ID_BUS" = "$bus" ]; then
        if [ -z "$serial" -o "$ID_SERIAL" = "$serial" ]; then
          if [ -n "$live" -a "$d" = "$live" ]; then
            # cannot install LiveOS over itself
            continue
          else
            echo $(readlink -e $d)
            return 0
          fi
        fi
      fi
    done
    return 1
}


start() {
    # oVirt boot parameters
    #   BOOTIF=link|eth*|<MAC> (appended by pxelinux)
    #   ovirt_init=usb|scsi[:serial#]
    #   ovirt_vol=BOOT_MB:SWAP_MB:ROOT_MB:CONFIG_MB:LOGGING_MB
    #   ovirt_local_boot
    #   ovirt_standalone
    #   pxelinux format: ip=<client-ip>:<boot-server-ip>:<gw-ip>:<netmask>
    #   anaconda format: ip=<client-ip> netmask=<netmask> gateway=<gw-ip>
    #   ipv6=dhcp|auto
    #   syslog=server[:port]
    #   TBD logrotate maxsize

    #   BOOTIF=link|eth*|<MAC> (appended by pxelinux)
    # network boot interface is assumed to be on management network where
    # oVirt Server is reachable
    # BOOTIF=<MAC> e.g. BOOTIF=01-00-16-3e-12-34-57
    # PXELINUX option IPAPPEND 2 in pxelinux.cfg appends MAC address
    # of the booting node
    # BOOTIF=link - take first eth for which ethtool reports link
    # BOOTIF=eth* e.g. BOOTIF=eth0 - use given interface
    bootif=

    #   ovirt_init=usb|scsi[:serial#]
    # local installation target disk
    # usb|scsi - select disk type, as reported by udev ID_BUS
    # serial# - select exact disk using serial number, as reported by
    #           udev ID_SERIAL
    # e.g. ovirt_init=usb:Generic_STORAGE_DEVICE_0000145418-0:0
    init=

    #   ovirt_vol=BOOT_MB:SWAP_MB:ROOT_MB:CONFIG_MB:LOGGING_MB
    # local partition sizes in GB
    vol_boot_size=
    vol_swap_size=
    vol_root_size=
    vol_config_size=
    vol_logging_size=

    #   ovirt_local_boot
    # install/update oVirt Node image on the local installation target disk
    local_boot=0

    #   ovirt_standalone
    # force oVirt Node standalone mode
    standalone=0

    #   pxelinux format: ip=<client-ip>:<boot-server-ip>:<gw-ip>:<netmask>
    #   anaconda format: ip=<client-ip> netmask=<netmask> gateway=<gw-ip>
    #   ipv6=dhcp|auto
    # static network configuration
    ip_address=
    ip_gateway=
    ip_netmask=
    netmask=
    gateway=
    ipv6=

    #   syslog=server[:port]
    # default syslog server
    syslog_server=
    syslog_port=

    # save boot parameters like console= for local disk boot menu
    bootparams=

    for i in $(cat /proc/cmdline); do
        case $i in
            BOOTIF=*)
            i=${i#BOOTIF=}
            case "$i" in
                eth*)
                bootif=$i
                ;;
                link)
                for eth in $(cd /sys/class/net; echo eth*); do
                    if ethtool $eth 2>/dev/null|grep -q "Link detected: yes"
                    then
                        bootif=$eth
                        break
                    fi
                done
                ;;
                ??-??-??-??-??-??-??)
                i=${i#??-}
                bootif=$(grep -il $(echo $i|sed 's/-/:/g') /sys/class/net/eth*/address|rev|cut -d/ -f2|rev)
                ;;
            esac
            ;;
            ovirt_init*)
            i=${i#ovirt_init}
            if [ -n "$i" ]; then
                # resolve to disk device
                case "$i" in
                    =scsi*)
                    bus=scsi
                    i=${i#=scsi}
                    serial=${i#:}
                    ;;
                    =usb*)
                    bus=usb
                    i=${i#=usb}
                    serial=${i#:}
                    ;;
                    *)
                    bus=
                    serial=
                    ;;
                esac
                if [ -n "$bus" ]; then
                    init=$(find_disk $bus $serial)
                fi
            else
                # 'ovirt_init' without value: grab first disk
                init=/dev/?da
            fi
            ;;
            ovirt_vol=*)
            i=${i#ovirt_vol=}
            eval $(printf $i|awk -F: '{print "vol_boot_size="$1; print "vol_swap_size="$2; print "vol_root_size="$3; print "vol_config_size="$4; print "vol_logging_size="$5;}')
            ;;
            ovirt_local_boot*)
            local_boot=1
            ;;
            ovirt_standalone*)
            standalone=1
            bootparams="$bootparams $i"
            ;;
            ip=*)
            i=${i#ip=}
            eval $(printf $i|awk -F: '{print "ip_address="$1; print "ip_gateway="$3; print "ip_netmask="$4}')
            ;;
            netmask=*)
            netmask=${i#netmask=}
            ;;
            gateway=*)
            gateway=${i#gateway=}
            ;;
            ipv6=*)
            ipv6=${i#ipv6=}
            ;;
            syslog=*)
            i=${i#syslog=}
            eval $(printf $i|awk -F: '{print "syslog_server="$1; print "syslog_port="$2;}')
            ;;
            console=*)
            bootparams="$bootparams $i"
            ;;
        esac
    done

    if [ -z "$ip_netmask" ]; then
        ip_netmask=$netmask
    fi
    if [ -z "$ip_gateway" ]; then
        ip_gateway=$gateway
    fi
    # save boot parameters as defaults for ovirt-config-*
    params="bootif init vol_boot_size vol_swap_size vol_root_size vol_config_size vol_logging_size local_boot standalone ip_address ip_netmask ip_gateway ipv6 syslog_server syslog_port bootparams"
    mount_config
    if [ -e $OVIRT_DEFAULTS ]; then
        echo "update ovirt defaults"
        tmpaug=$(mktemp)
        for p in $params; do
            PARAM=$(uc $p)
            value=$(ptr $p)
            echo "set /files$OVIRT_DEFAULTS/OVIRT_$PARAM '\"$value\"'" \
                >> $tmpaug
        done
        echo "save" >> $tmpaug
        # augtool on bindmounted files fails
        umount_config $OVIRT_DEFAULTS
        augtool < $tmpaug > /dev/null
        ovirt_store_config $OVIRT_DEFAULTS
        rm $tmpaug
    else
        echo "initial startup"
        # dump all ovirt bootparams
        mkdir -p $(dirname $OVIRT_DEFAULTS)
        echo > $OVIRT_DEFAULTS
        for p in $params; do
            PARAM=$(uc $p)
            echo "OVIRT_$PARAM='$(ptr $p)'" >> $OVIRT_DEFAULTS
        done
        ovirt_store_config $OVIRT_DEFAULTS
    fi

    if [ $standalone = 0 ]; then
        configure_from_network $bootif
        if [ -n "$init" ]; then
            ovirt-config-storage AUTO
            # initial configuration storage, after /config creation
            ovirt_store_config \
                /etc/sysconfig/network-scripts/ifcfg-* \
                $BONDING_MODCONF_FILE
            if [ $local_boot = 1 ]; then
                # local disk installation for managed mode
                ovirt-config-boot $init "" "$bootparams"
            fi
        fi
    fi
}

scan_for_swap() {
    # swap partition activation
    # find all of the partitions on the system

    # get the system pagesize
    PAGESIZE=`getconf PAGESIZE`

    # look first at raw partitions XXX disk/by-id or HAL? (for cciss)
    BLOCKDEVS=`ls /dev/sd? /dev/hd? 2>/dev/null`

    # now LVM partitions
    LVMDEVS="$DEVICES `lvscan | awk '{print $2}' | tr -d \"'\"`"

    SWAPDEVS="$LVMDEVS"
    for dev in $BLOCKDEVS; do
        SWAPDEVS="$SWAPDEVS `fdisk -l $dev 2>/dev/null | tr '*' ' ' \
                                     | awk '$5 ~ /82/ {print $1}'`"
    done

    # now check if any of these partitions are swap, and activate if so
    for device in $SWAPDEVS; do
        sig=`dd if=$device bs=1 count=10 skip=$(( $PAGESIZE - 10 )) \
            2>/dev/null`
        if [ "$sig" = "SWAPSPACE2" ]; then
            swapon $device
        fi
    done
}

case "$1" in
    start)
        printf "Starting ovirt-early: "

        {
            start
        } >> $OVIRT_LOGFILE 2>&1

        test $? == 0 && success || failure
        echo
        ;;
    *)
        echo "Usage: ovirt-early {start}"
        exit 2
esac
