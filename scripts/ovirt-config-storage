#!/bin/bash
#
# To automate the partitioning, pass in the specific fields in this order
# ovirt-config-storage [swap size] [boot size] [root size] [logging size] [data size]
#
# All sizes are in megabytes
#

. /etc/init.d/ovirt-functions

ME=$(basename "$0")
warn() { printf '%s: %s\n' "$ME" "$*" >&2; }
die() { warn "$*"; exit 1; }

trap '__st=$?; stop_log; exit $__st' 0
trap 'exit $?' 1 2 13 15

# check that we're not booted from local storage; if so then exit with an error
if is_booted_from_local_disk; then
    die "You cannot configure storage on a running system. Please boot from CD/USB to configure local storage."
fi

default_overcommit=0.5

default_root_size=256
default_config_size=5
default_logging_size=2048
# -1 indicates data partition should use remaining disk
default_data_size=-1

root_min_size=256
config_min_size=5
logging_min_size=5
data_min_size=5
swap_min_size=5

get_drive_size()
{
    local drive=$1
    local space_var=$2

    local size=
    local udi=$(hal-find-by-property --key block.device --string $drive)
    # if more than one UDI was found then iterate over them to find the base device
    if [[ "${udi}" =~ \$  ]]; then
        udi=$(echo $udi | sed 's/\$/ /g')
        for found in ${udi}; do
            if [[ "false" == $(hal-get-property --udi $found --key block.is_volume) ]]; then
                udi=$found
                break
            fi
        done
    fi
    if [ -z "$udi" ]; then
        # If hal didn't find the device, it could be a virtio block device
        # In this case, use sfdisk -s to get the size
        size=$(sfdisk -s $drive)
        size=$(echo "scale=0; $size * 1024" | bc -l)
    else
        size=$(hal-get-property --udi "$udi" --key storage.size)
        if [[ "${size}" == "0" ]]; then
            # disk is probably hot-swappable, use different HAL key
            # but first check that it is removeable media and that  media is present
            if [[ "true" == "$(hal-get-property --udi "$udi" --key storage.removable.media_available)" ]]; then
                size=$(hal-get-property --udi "$udi" --key storage.removable.media_size)
            fi
        fi
    fi

    size=$(echo "scale=0; $size / (1024 * 1024)" | bc -l)
    echo "$drive ($size MB)"
    echo "Disk Identifier: $(basename "$udi")"
    if [ -n "$space_var" ]; then
        eval $space_var=$size
    fi
}

check_partition_sizes()
{
    local disk_size need_size

    local min_data_size=$DATA_SIZE
    if [ "$DATA_SIZE" = -1 ]; then
        min_data_size=5
    fi

    printf "\n"
    get_drive_size $DRIVE SPACE
    disk_size=$SPACE
    need_size=$(echo "scale=0;" \
                     "$SWAP_SIZE + $ROOT_SIZE * 2" \
                     "+ $CONFIG_SIZE + $LOGGING_SIZE + $min_data_size" | bc -l)

    if [ $need_size -gt $disk_size ]; then
        local gap_size=$(echo "scale=0; $need_size-$disk_size;" | bc -l)
        printf "\n"
        printf "=============================================================\n"
        printf "The target storage device is too small for the desired sizes:\n"
        printf " Size of target storage device: $disk_size MB\n"
        printf " Total storage size to be used: $need_size MB\n"
        printf "\n"
        printf "You need an addition $gap_size MB of storage.\n"
        printf "\n"
        return 1
    else
        printf "Required Space : $need_size MB\n\n"
    fi

    # check if an existing HostVG exists on a device other than the target
    devices="$(pvs -o pv_name,vg_name --noheadings | \
        grep "HostVG"|grep -v $DRIVE|awk '{ print $1 }')"
    rc=0
    if [ -n "$devices" ]; then
        printf "\n"
        printf "There appears to already be an installation on another device:\n"
        for device in $devices; do
            udi=$(hal-find-by-property --key block.device --string $device)
            printf "\t$device ($(basename "$udi"))\n"
        done
        printf "We cannot proceed until either device is removed from the system\n"
        printf "or until the HostVG volume group is removed.\n"
        printf "\nTo re-install the node, please select \"Uninstall Node\" from the main\n"
        printf "menu and then try to partition.\n"
        printf "\n"
        rc=1
    fi

    return $rc
}

# Find a usable/selected storage device.
# If there are none, give a diagnostic and return nonzero.
# If there is just one, e.g., /dev/sda, treat it as selected (see below).
# and return 0.  If there are two or more, make the user select one
# or decline.  Upon decline, return nonzero. Otherwise, print the
# selected name, then return 0.
# Sample output: /dev/sda
get_dev_name()
{
    local udi_list=$(hal-find-by-capability --capability storage)
    if test -z "$udi_list"; then
        warn "ERROR: no usable storage devices detected"
        return 1
    fi

    local d devices sizes
    for d in $udi_list; do
        local drive_type=$(hal-get-property --udi "$d" --key storage.drive_type)
        test "X$drive_type" = Xdisk || continue
        local block_dev=$(hal-get-property --udi "$d" --key block.device)
        # Must start with a '/'.
        case $block_dev in
            *' '*)
                # we use space as separator
                warn "block device name '$block_dev' contains space; skipping";
                continue;;
            /*) ;;
            *) warn "block device name $block_dev doesn't start with '/';" \
                " skipping"; continue;;
        esac
        test -z "$devices" \
            && devices="$block_dev" \
            || devices="$devices $block_dev"
    done

    # FIXME: workaround for detecting virtio block devices
    devices="$devices $(ls /dev/vd? 2> /dev/null | xargs)"
    devices=$(echo $devices | tr ' ' '\n' | sort -u | xargs)

    local num_devices=$(echo "$devices" | wc -w)
    # If there's only one device, use it.
    case $num_devices in
        0) warn "ERROR: found no usable block device"; return 1;;
        1) echo "$devices"; return 0;;
        *) ;; # found more than one
    esac

    # There are two or more; make the user choose.
    # display description for each disk
    for d in $devices; do
        get_drive_size $d >&2
    done
    local choices="$devices Abort"
    select device in $choices
    do
        test "$device" = Abort && return 1
        test -z "$device" && continue
        echo "$device"
        return 0
    done
}

do_configure()
{
    local name_and_size
    DRIVE=$(get_dev_name) || return 0
    get_drive_size $DRIVE SPACE

    printf "\n\nPlease configure storage partitions.\n\n"
    printf "* Enter partition sizes in MB.\n"
    printf "* A value of 0 indicates the partition should be disabled.\n"
    printf "* If the partition is enabled, it will have a minimum valid size.\n"
    printf "* Size remaining value is approximate due to cylinder rounding\n"
    printf "  during partitioning.\n"
    printf "* For the Data partition, a size of -1 indicates that the\n"
    printf "  partition should use up the remaining space on the disk.\n\n"

    do_review
    if ask_yes_or_no "Use these default values ([Y]es/[N]o)?"; then
        return
    fi

    local space_left=$SPACE
    for part in swap root config logging data ; do
        part_regexp="^0$"
        if [ "$part" = "data" ]; then
            part_regexp="^\-1|0$"
        fi
        uc=$(echo $part|tr '[[:lower:]]' '[[:upper:]]')
        size_var=${uc}_SIZE
        eval "size=\$$size_var"
        min_size_var=${part}_min_size
        eval "min_size=\$$min_size_var"

        while true; do
            printf "\n"
            read -ep "Change $part partition size. (Def. ${size}MB), Min. ${min_size}MB, Max. ~${space_left}MB? or Q to quit "
            mb_input=$REPLY
            test -z "$mb_input" && mb_input=$size
            local size_used=0
            if [[ $mb_input == "q" || $mb_input == "Q" ]]; then
                printf "Aborting"
                return
            elif [[ $mb_input =~ ^-*[0-9]+$ ]]; then
                if [[ $mb_input -ge $min_size || $mb_input =~ $part_regexp ]] \
                    && [[ $mb_input -le $space_left ]] ; then
                    eval "$size_var=$mb_input"
                    size_used=$mb_input
                    break;
                else
                    printf "invalid $part size: $mb_input.  "
                    printf "Does not fall into specified range.\n"
                fi
            else
                printf "invalid $part size: '$mb_input'.\n"
            fi
        done
        space_left=$(echo "scale=0;$space_left - $size_used" | bc -l)
    done

    if ! check_partition_sizes; then
        printf "Please try partitioning again.\n"
        DRIVE=
        return 1
    fi

    # save input variables
    augtool <<EOF
set /files$OVIRT_DEFAULTS/OVIRT_INIT $DRIVE
set /files$OVIRT_DEFAULTS/OVIRT_VOL_SWAP_SIZE $SWAP_SIZE
set /files$OVIRT_DEFAULTS/OVIRT_VOL_ROOT_SIZE $ROOT_SIZE
set /files$OVIRT_DEFAULTS/OVIRT_VOL_CONFIG_SIZE $CONFIG_SIZE
set /files$OVIRT_DEFAULTS/OVIRT_VOL_LOGGING_SIZE $LOGGING_SIZE
set /files$OVIRT_DEFAULTS/OVIRT_VOL_DATA_SIZE $DATA_SIZE
EOF
}

do_review()
{
    if [ -z "$DRIVE" ]; then
        printf "\nNo storage device selected.\n"
        return
    fi

    local data_size_display="$DATA_SIZE MB"
    if [ "$DATA_SIZE" = -1 ]; then
        local remaining_mb=$(( $SPACE - $SWAP_SIZE \
                - $ROOT_SIZE * 2 - $CONFIG_SIZE - $LOGGING_SIZE ))
        data_size_display="$remaining_mb MB"
    fi

    cat <<EOF

The local disk will be repartitioned as follows:
================================================
           Physical Hard Disk: $(get_drive_size $DRIVE)
          Swap partition size: $SWAP_SIZE MB
  Installation partition size: $ROOT_SIZE * 2 MB
 Configuration partition size: $CONFIG_SIZE MB
       Logging partition size: $LOGGING_SIZE MB
          Data partition size: $data_size_display

EOF
}

# cleanup lvms on selected disk
# - remove mounted filesystems
# - remove LVM volumes and groups
wipe_lvm_on_disk()
{
    unmount_logging
    for vg in $(pvs -o vg_name --noheadings $DRIVE* 2>/dev/null|sort -u); do
        wipe_volume_group $vg
    done
}

perform_partitioning()
{
    log "Partitioning drive: $DRIVE"
    if [ -z "$DRIVE" ]; then
        printf "\nNo storage device selected.\n"
        return
    fi

    start_log
    log "Starting partitioning of $DRIVE"

    log "Saving parameters"
    unmount_config /etc/default/ovirt

    log "Removing old LVM partitions"
    wipe_lvm_on_disk

    # begin critical section
    set -e

    # FIXME: save a backup copy, just in case?
    log "Wiping old boot sector"
    dd if=/dev/zero of=$DRIVE bs=1024K count=1
    blockdev --rereadpt $DRIVE
    partprobe -s $DRIVE

    MEM_SIZE_MB=$(echo "scale=0; $MEM_SIZE_MB / 1024;" | bc -l)
    log "Labeling Drive"
    parted $DRIVE -s "mklabel ${LABEL_TYPE}"
    log "Creating Root and RootBackup Partitions"
    let RootBackup_end=${ROOT_SIZE}*2
    parted $DRIVE -s "mkpartfs primary ext2 0M ${ROOT_SIZE}M"
    parted $DRIVE -s "mkpartfs primary ext2 ${ROOT_SIZE}M ${RootBackup_end}M"
    # sleep to ensure filesystems are created before continuing
    sleep 10
    e2label ${DRIVE}1 Root
    e2label ${DRIVE}2 RootBackup
    tune2fs -c 0 -i 0 ${DRIVE}1
    tune2fs -c 0 -i 0 ${DRIVE}2
    log "Creating LVM partition"
    parted $DRIVE -s "mkpart primary ext2 ${RootBackup_end}M -1"
    log "Toggling LVM on"
    parted $DRIVE -s "set 3 lvm on"
    parted $DRIVE -s "print"
    udevadm settle 2> /dev/null || udevsettle

    # sync GPT to the legacy MBR partitions
    if [ "gpt" == "$LABEL_TYPE" ]; then
        log "Running gptsync to create legacy mbr"
        gptsync $DRIVE
    fi

    partpv=${DRIVE}3
    if [ ! -e "$partpv" ]; then
        # e.g. /dev/cciss/c0d0p2
        partpv=${DRIVE}p3
    fi
    log "Creating physical volume"
    if [ ! -e "$partpv" ]; then
        log "$partpv is not available!"
        exit 1
    fi
    dd if=/dev/zero of=${partpv} bs=1024k count=1
    pvcreate -ff -y "${partpv}"
    log "Creating volume group"
    vgcreate /dev/HostVG "${partpv}"

    mkdir -p /dev/disk/by-label

    if [ "$SWAP_SIZE" -gt 0 ]; then
        log "Creating swap partition"
        lvcreate --name Swap --size ${SWAP_SIZE}M /dev/HostVG
        mkswap -L "SWAP" /dev/HostVG/Swap
        echo "/dev/HostVG/Swap swap swap defaults 0 0" >> /etc/fstab
    fi
    if [ "$CONFIG_SIZE" -gt 0 ]; then
        log "Creating config partition"
        lvcreate --name Config --size ${CONFIG_SIZE}M /dev/HostVG
        mke2fs -j /dev/HostVG/Config -L "CONFIG"
        tune2fs -c 0 -i 0 /dev/HostVG/Config
    fi
    if [ "$LOGGING_SIZE" -gt 0 ]; then
        log "Creating log partition"
        lvcreate --name Logging --size ${LOGGING_SIZE}M /dev/HostVG
        mke2fs -j /dev/HostVG/Logging -L "LOGGING"
        tune2fs -c 0 -i 0 /dev/HostVG/Logging
        echo "/dev/HostVG/Logging /var/log ext3 defaults 0 0" >> /etc/fstab
    fi

    local use_data=1
    if [ "$DATA_SIZE" -eq -1 ]; then
        log "Creating data partition with remaining free space"
        lvcreate --name Data -l 100%FREE /dev/HostVG
        use_data=0
    elif [ "$DATA_SIZE" -gt 0 ]; then
        log "Creating data partition"
        lvcreate --name Data --size ${DATA_SIZE}M /dev/HostVG
        use_data=0
    fi

    if [ "$use_data" = 0 ]; then
        mke2fs -j /dev/HostVG/Data -L "DATA"
        tune2fs -c 0 -i 0 /dev/HostVG/Data
        echo "/dev/HostVG/Data /data ext3 defaults 0 0" >> /etc/fstab
        echo "/data/images /var/lib/libvirt/images bind bind 0 0" >> /etc/fstab
        echo "/data/core /var/log/core bind bind 0 0" >> /etc/fstab
    fi

    # end critical section
    set +e

    log "Mounting config partition"
    if mount_config; then
        ovirt_store_config /etc/fstab
    fi

    mount_logging
    if [ "$use_data" = 0 ]; then
        log "Mounting data partition"
        mount_data
    fi
    log "Completed!"

    stop_log
}

do_confirm()
{
    if [ -z "$DRIVE" ]; then
        printf "\nNo storage device selected.\n"
        return
    fi

    while true; do
        sp='                                                    '
        w='!!WARNING'
        wb="$w"'!!'
        w8="$w$w$w$w$w$w$w$w"
        printf '%s!!\n' \
          "$w8" \
          "$w8" \
          "$wb$sp$w" \
          "$wb$sp$w" \
          "$wb    If you proceed, this will destroy all data on   $w" \
          "$wb    your local system, and your hard disk will be   $w" \
          "$wb    irreversably reconfigured                       $w" \
          "$wb$sp$w" \
          "$wb$sp$w" \
        "$w8" \
        "$w8"

        if ask_yes_or_no "Do you wish to proceed ([Y]es/[N]o)?"; then
            if check_partition_sizes; then
                perform_partitioning
                exit 0
            fi
        else
            return
        fi
    done
}

MEM_SIZE_MB=$(awk '/MemTotal:/ { print $2 }' /proc/meminfo)
case $MEM_SIZE_MB in
    ''|*[^0-9]*) die failed to get system memory size;;
esac
MEM_SIZE_MB=$(echo "scale=0; $MEM_SIZE_MB / 1024;" | bc -l)

overcommit=${OVIRT_OVERCOMMIT:-$default_overcommit}
# we multiply the overcommit coefficient by 10 then divide the
# product by 10 to avoid decimals in the result
OVERCOMMIT_SWAP_SIZE=$(echo "scale=0; (${MEM_SIZE_MB} * (${overcommit} * 10))/10;" | bc -l)

# add to the swap the amounts from http://kbase.redhat.com/faq/docs/DOC-15252
MEM_SIZE_GB=$(echo "scale=0; $MEM_SIZE_MB/1024;" | bc -l)
if [ $MEM_SIZE_GB -le 4 ]; then
    BASE_SWAP_SIZE=2048
elif [ $MEM_SIZE_GB -le 16 ]; then
    BASE_SWAP_SIZE=4096
elif [ $MEM_SIZE_GB -le 64 ]; then
    BASE_SWAP_SIZE=8192
else
    BASE_SWAP_SIZE=16384
fi

CALC_SWAP_SIZE=$(echo "scale=0; ${BASE_SWAP_SIZE} + ${OVERCOMMIT_SWAP_SIZE};" | bc -l)

SWAP_SIZE=${OVIRT_VOL_SWAP_SIZE:-$CALC_SWAP_SIZE}
ROOT_SIZE=${OVIRT_VOL_ROOT_SIZE:-$default_root_size}
CONFIG_SIZE=${OVIRT_VOL_CONFIG_SIZE:-$default_config_size}
LOGGING_SIZE=${OVIRT_VOL_LOGGING_SIZE:-$default_logging_size}
DATA_SIZE=${OVIRT_VOL_DATA_SIZE:-$default_data_size}

if [ -n "$OVIRT_INIT" ]; then
    # if present, use the drive selected with 'ovirt_init' boot parameter
    DRIVE=$OVIRT_INIT
    get_drive_size $DRIVE SPACE
fi

# if the node is Fedora then use GPT, otherwise use MBR
if [ -f /etc/fedora-release ]; then
    LABEL_TYPE="gpt"
else
    LABEL_TYPE="msdos"
fi

if [ "$1" == "AUTO" ]; then
    log "Beginning automatic disk partitioning.\n"
    if [ -n "$OVIRT_INIT" ]; then
        # do not format if HostVG exists on selected disk...
	pvs -o vg_name --noheadings $DRIVE* 2>/dev/null|grep -q -m1 "HostVG"
	existingHostVG=$?
        # ... unless overridden by ovirt_firstboot parameter
	if is_firstboot || [ $existingHostVG -ne 0 ]; then
            if check_partition_sizes; then
		log "Partitioning hard disk..."
		perform_partitioning
            fi
	else
            log "Skip disk partitioning, HostVG exists"
	fi
    else
	log "Missing device parameter: unable to partition any disk"
    fi
else
    OPTIONS="\"Configure\" \"Review\" \"Commit Changes And Quit\" \"Return To Menu\""
    eval set $OPTIONS
    PS3="Choose an option: "

    while true; do
        printf "\n\n Storage Configuration\n\n" >&2

        select OPTION in "$@"
        do
            case "$OPTION" in
                "Configure") do_configure ; break ;;
                "Review")    do_review    ; break ;;
                "Commit Changes And Quit") do_confirm   ; break ;;
                "Return To Menu")      printf "\nExiting.\n"; exit ;;
            esac
        done
    done
fi
