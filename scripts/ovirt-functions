# -*-Shell-script-*-

OVIRT_LOGFILE=/var/log/ovirt.log
OVIRT_TMP_LOGFILE=/tmp/ovirt.log
_log_status=1

# label of the oVirt partition
OVIRT_LABEL=OVIRT
# configuration defaults
OVIRT_DEFAULTS=/etc/default/ovirt
if [ -f $OVIRT_DEFAULTS ]; then
    . $OVIRT_DEFAULTS
fi
# fallback when default is empty
OVIRT_STANDALONE=${OVIRT_STANDALONE:-0}

OVIRT_BACKUP_DIR=/var/lib/ovirt-backup

MANAGEMENT_SCRIPTS_DIR=/etc/node.d

OVIRT_CONFIG_FILES="\
 /etc/sysconfig/network-scripts/ifcfg-*         \
 /etc/rsyslog.conf                              \
 /etc/libvirt/libvirtd.conf                     \
 /etc/sasl2/libvirt.conf                        \
 /etc/libvirt/passwd.db                         \
 /etc/passwd                                    \
 /etc/shadow                                    \
 /etc/ssh/ssh_host*_key*                        \
 /etc/default/ovirt                             \
 /etc/sysconfig/network                         \
 /etc/collectd.conf                             \
 /etc/logrotate.d/ovirt-logrotate.conf
"

# Save stdout to fd 6 and stderr to fd 7.  Redirect normal stdout/stderr
# to log file
start_log() {
    if [ "$_log_status" = 1 ]; then
        exec 6>&1
        exec 7>&2
        exec 1>>$OVIRT_TMP_LOGFILE
        exec 2>&1
        _log_status=0
    fi
}

# Restore stdout/stderr from fd 6 and 7, respectively.  Close fd 6 and 7
stop_log() {
    if [ "$_log_status" != 1 ]; then
        exec 1>&6 6>&-
        exec 2>&7 7>&-
        _log_status=1
    fi
}

log() {
    printf "$(date +'%b %d %H:%M:%S') "

    if [ "$_log_status" = 1 ]; then
        echo "$@"
    else
        echo "$@" >&6
    fi
}

ovirt_store_firstboot_config() {
    # persist config for standalone
    ovirt_store_config $OVIRT_CONFIG_FILES
}

# return 1 if oVirt Node is running in standalone mode
# return 0 if oVirt Node is managed by the oVirt Server
is_managed() {
    return $OVIRT_STANDALONE
}

# oVirt Node in standalone mode does not try to contact the oVirt Server
is_standalone() {
    if is_managed; then return 1; else return 0; fi
}

# return 0 if local storage is configured
# return 1 if local storage is not configured
is_local_storage_configured () {
    if lvs HostVG/Config >/dev/null >&1; then
        return 0
    fi

    return 1
}

# perform automatic local disk installation
# when at least following boot parameters are present:
# for networking - OVIRT_BOOTIF, management NIC
#       if other ip bootparams are not specified, IPv4 DHCP is assumed
# for storage - OVIRT_INIT, local disk to use
#       if ovirt_vol is not specified, default volume sizes are set
is_auto_install() {
    if [ -n "$OVIRT_BOOTIF" -a -n "$OVIRT_INIT" ] ; then
        return 0
    else
        return 1
    fi
}

# return 0 if this is an upgrade
# return 1 otherwise
is_upgrade() {
    if [ "$OVIRT_UPGRADE" = "1" ]; then
        return 0
    else
        return 1
    fi
}

# return 0 if booted from local disk
# return 1 if booted from other media
is_booted_from_local_disk() {
    grep -q /dev/HostVG/ /proc/cmdline
}

# was firstboot menu already shown?
# state is stored in persistent config partition
is_firstboot() {
    if [ -z "$OVIRT_FIRSTBOOT" -o "$OVIRT_FIRSTBOOT" = "1" ]; then
        return 0
    else
        return 1
    fi
}

disable_firstboot() {
    if mount_config; then
        augtool <<EOF
set /files$OVIRT_DEFAULTS/OVIRT_FIRSTBOOT 0
set /files$OVIRT_DEFAULTS/OVIRT_INIT '""'
set /files$OVIRT_DEFAULTS/OVIRT_UPGRADE 0
EOF
    fi
}

# Destroys a particular volume group and its logical volumes.
#
wipe_volume_group()
{
    vg=$1

    for d in $(grep $vg /proc/mounts|awk '{print $2}'); do
        log "Unmounting $d"
        umount $d
    done
    for d in $(grep $vg /proc/swaps|awk '{print $1}'); do
        log "Turning off $d"
        swapoff $d
    done
    log "Removing $vg"
    vgremove -f $vg
}

# find_srv SERVICE PROTO
#
# reads DNS SRV record
# sets SRV_HOST and SRV_PORT if DNS SRV record found, clears them if not
# Example usage:
# find_srv ovirt tcp
# if [ -n "$SRV_HOST" -a -n "$SRV_PORT" ]; then
#   echo "oVirt Server found"
# else
#   echo "no oVirt Server available, running standalone"
# fi
find_srv()
{
    local dnsreply
    local domain=$(dnsdomainname 2>/dev/null)
    if [ "$domain" = "localdomain" ]; then
        domain=""
    fi
    # FIXME dig +search does not seem to work with -t srv
    # dnsreply=$(dig +short +search -t srv _$1._$2)
    # This is workaround:
    local search=$(grep search /etc/resolv.conf)
    search=${search#search }
    for d in $domain $search; do
        dnsreply=$(dig +short -t srv _$1._$2.$d)
        rc=$?
        if [ $rc -eq 0 ]; then
            set _ $dnsreply; shift
            SRV_HOST=$4; SRV_PORT=$3
            return 0
        fi
    done
    SRV_HOST=; SRV_PORT=
    return 1
}

die()
{
    echo "$@" 1>&2; failure; echo 1>&2; exit 1
}

ovirt_setup_libvirtd() {
    # just to get a boot warning to shut up
    touch /etc/resolv.conf

    # make libvirtd listen on the external interfaces
    sed -i -e 's/^#\(LIBVIRTD_ARGS="--listen"\).*/\1/' \
       /etc/sysconfig/libvirtd

    # set up qemu daemon to allow outside VNC connections
    sed -i -e 's/^[[:space:]]*#[[:space:]]*\(vnc_listen = "0.0.0.0"\).*/\1/' \
       /etc/libvirt/qemu.conf
    # set up libvirtd to listen on TCP (for kerberos)
    sed -i -e "s/^[[:space:]]*#[[:space:]]*\(listen_tcp\)\>.*/\1 = 1/" \
       -e "s/^[[:space:]]*#[[:space:]]*\(listen_tls\)\>.*/\1 = 0/" \
       /etc/libvirt/libvirtd.conf

    # with libvirt (0.4.0), make sure we we setup gssapi in the mech_list
    sasl_conf=/etc/sasl2/libvirt.conf
    if ! grep -qE "^mech_list: gssapi" $sasl_conf ; then
       sed -i -e "s/^\([[:space:]]*mech_list.*\)/#\1/" $sasl_conf
       echo "mech_list: gssapi" >> $sasl_conf
    fi
}

ovirt_setup_anyterm() {
   # configure anyterm
   cat >> /etc/sysconfig/anyterm << EOF
ANYTERM_CMD="sudo /usr/bin/virsh console %p"
ANYTERM_LOCAL_ONLY=false
EOF

   # permit it to run the virsh console
   echo "anyterm ALL=NOPASSWD: /usr/bin/virsh console *" >> /etc/sudoers
}

md5() {
  md5sum $1 2>/dev/null | (read MD5 filename; echo $MD5)
}

# return uppercase value
uc() {
    echo $(echo $1|tr '[[:lower:]]' '[[:upper:]]')
}

# return indirect value
# non-bashism for ${!var}
ptr() {
    local v=$1
    eval "v=\$$v"
    echo $v
}

# mount livecd media
# e.g. CD /dev/sr0, USB /dev/sda1,
# PXE /dev/loop0 (loopback ISO)
# not available when booted from local disk installation
mount_live() {
    if grep -q " /live " /etc/mtab; then
        return 0
    fi
    local live_dev=/dev/live
    if [ ! -e $live_dev ]; then
        if losetup /dev/loop0|grep -q '\.iso'; then
            # PXE boot
            live_dev=/dev/loop0
        else
            return 1
        fi
    fi
    mkdir -p /live
    mount -r $live_dev /live || mount $live_dev /live
}

# mount root partition
# boot loader + kernel + initrd + LiveOS
mount_liveos() {
    if grep -q " /liveos " /etc/mtab; then
        return 0
    fi
    mkdir -p /liveos
    mount /dev/disk/by-label/Root /liveos
}

# mount config partition
# /config for persistance
mount_config() {
    # Only try to mount /config if the persistent storage exists
    if [ -e /dev/HostVG/Config ] ; then
        mkdir -p /config
        if ! grep -q " /config ext3 " /proc/mounts; then
            mount /dev/HostVG/Config /config || return 1
        fi

        # optional config embedded in the livecd image
        if [ -e /live/config ]; then
            cp -rv --update /live/config/* /config
        fi
        # bind mount all persisted configs to rootfs
        for f in $(find /config -type f); do
            target=${f#/config}
            if grep -q " $target ext3" /proc/mounts ; then
                # skip if already bind-mounted
                true
            else
                mkdir -p "$(dirname $target)"
                touch "$target"
                mount -n --bind $f "$target"
            fi
        done

        return 0
    else
        # /config is not available
        return 1
    fi
}

mount_boot() {

    if grep -q " /boot " /etc/mtab; then
       return 0
    fi
    mkdir -p /boot
    mount /dev/disk/by-label/Boot /boot
}
# stop any service which keeps /var/log busy
# keep the list of services
unmount_logging_services() {
    # mapping command->service is lame, but works for most initscripts
    services=
    cd /etc/init.d
    for prg in $(lsof -Fc +D /var/log|grep ^c|sort -u); do
        srv=$(grep -l ${prg#c}$ *)
        service $srv stop 6>&- 7>&-
        services="$services $srv"
    done
    # debugging help
    lsof +D /var/log
}

# mount logging partition
# this only gets executed when disk is re-partitioned, HostVG/Logging is empty
mount_logging() {
    if grep -q " /var/log ext3" /proc/mounts; then
        return 0
    fi

    if [ -e /dev/HostVG/Logging ] ; then
        log "Mounting log partition"

        # temporary mount-point
        log2=$(mktemp -d)
        mkdir -p $log2
        mount /dev/HostVG/Logging $log2
        unmount_logging_services
        # save logs from tmpfs
        cp -av /var/log/* $log2
        # save temporary log
        if [ -e /tmp/ovirt.log ]; then
            cp /tmp/ovirt.log $log2/ovirt.log-tmp
        fi
        mount --move $log2 /var/log
        rmdir $log2
        restorecon -rv /var/log
        for srv in $services; do
            service $srv start 6>&- 7>&-
        done

        return 0
    else
        # /var/log is not available
        printf "\nThe logging partion has not been created. Please create it at the main menu.\n"
        return 1
    fi
}

unmount_logging() {
    if ! grep -q " /var/log ext3" /proc/mounts; then
        return 0
    fi

    log "Unmounting log partition"
    # plymouthd keeps /var/log/boot.log
    if plymouth --ping ; then
        plymouth --quit
    fi
    unmount_logging_services

    umount /var/log
    rc=$?
    if [ $rc -ne 0 ]; then
        return $rc
    fi
    for srv in $services; do
        service $srv start 6>&- 7>&-
    done

    return 0
}

# mount data partition
mount_data() {
    if grep -q " /data ext3" /proc/mounts; then
        return 0
    fi

    if [ -e /dev/HostVG/Data ] ; then
        mkdir -p /data
        mount /data
        mkdir -p /data/images
        mkdir -p /var/lib/libvirt/images
        mount /var/lib/libvirt/images
        restorecon -rv /var/lib/libvirt/images

        mkdir -p /data/core
        mkdir -p /var/log/core
        mount /var/log/core
        restorecon -rv /var/log/core

        return 0
    else
        # /data is not available
        printf "\nThe data partion has not been created. Please create it at the main menu.\n"
        return 1
    fi
}

# augtool wrapper
#   workaround for bind-mounted files
#   see https://fedorahosted.org/augeas/ticket/32
# augtool [tmpaugscript]
# script MUST NOT include save, it is added by the wrapper
# with copy_if_rename_fails flag set
# 'tmpaugscript' is removed after successfull execution
# without a parameter, augtool commands are expected on standard input
augtool() {
    local tmpaug=$1
    if [ -z "$1" ]; then
        # read from stdin
        tmpaug=$(mktemp)
        cat > $tmpaug
    fi
    cat >> $tmpaug <<EOF
clear /augeas/save/copy_if_rename_fails
save
EOF
    /usr/bin/augtool < $tmpaug > /dev/null
    rc=$?
    if [ $rc -eq 0 ]; then
        rm $tmpaug
    fi
    return $rc
}

# persist configuration to /config
#   ovirt_store_config /etc/config /etc/config2 ...
#   copy to /config and bind-mount back
ovirt_store_config() {
    rc=0
    if grep -q " /config ext3" /proc/mounts; then
        printf "storing to /config :\n"
        for p in "$@"; do
            f=$(readlink -f $p)
            printf "$f"
            # skip if file does not exist or is empty
            if [ ! -s "$f" ]; then
                printf " Skipping, file '%s' does not exist or is empty\n" $p
                continue
            fi
            # skip if already bind-mounted
            if ! grep -q " $f ext3" /proc/mounts ; then
                mkdir -p /config$(dirname $f)
                cp -a $f /config$f \
                && mount -n --bind /config$f $f
                if [ $? -ne 0 ]; then
                    printf " Failed to persist\n"
                    rc=1
                else
                    printf " File persisted\n"
                fi
            fi
            # register in /config/files used by rc.sysinit
            if ! grep -q "^$f$" /config/files 2> /dev/null ; then
                printf "$f\n" >> /config/files
            fi
        done
        echo
    else
        printf "warning: persistent config storage not available\n"
        rc=2
    fi
    return $rc
}

# unmount bindmounted config files
#       unmount_config /etc/config /etc/config2 ...
#
# Use before running commands which fail on bindmounted files.
# After the file is replaced, call ovirt_store_config /etc/config ...
# to bindmount the config file again.
#
unmount_config() {
    if grep -q " /config ext3" /proc/mounts; then
        for p in "$@"; do
            f=$(readlink -f $p)
            if grep -q " $f ext3" /proc/mounts ; then
                if umount -n $f; then
                    if [ -f /config$f ]; then
                        # refresh the file in rootfs if it was mounted over
                        cp -a /config$f $f
                    fi
                fi
            fi
        done
    fi
}

# remove persistent config files
#       remove_config /etc/config /etc/config2 ...
#
remove_config() {
    if grep -q " /config ext3" /proc/mounts; then
        for p in "$@"; do
            f=$(readlink -f $p)
            if grep -q " $f ext3" /proc/mounts ; then
                if umount -n $f; then
                    if [ -f /config$f ]; then
                        # refresh the file in rootfs if it was mounted over
                        cp -a /config$f $f
                        if [ $? -ne 0 ]; then
                            printf " Failed to unpersist %s\n" $f
                        else
                            printf " %s successully unpersisted\n" $f
                        fi
                    fi
                fi
            else
                printf " %s is not in persistent storage" $f
            fi
            # clean up the persistent store
            rm -f /config$f
            # unregister in /config/files used by rc.sysinit
            sed --copy -i "\|^$f$|d" /config/files
        done
    fi
}

# ovirt_safe_delete_config
#       ovirt_safe_delete_config /etc/config /etc/config2 ...
#
# Use to *permanently* remove persisted configuration file.
# WARNING: file is shredded and removed
#
ovirt_safe_delete_config() {
    if grep -q " /config ext3" /proc/mounts; then
        for f in "$@"; do
            if grep -q " $f ext3" /proc/mounts ; then
                umount -n $f
            fi
            # unregister in /config/files used by rc.sysinit
            sed --copy -i "\|^$f$|d" /config/files
            shred -u /config$f
        done
    fi
    shred -u $f
}


# compat function to handle different udev versions
udev_info() {
    local name=$1
    local query=$2
    local out

    # old udev command with shortopts
    out=$(udevinfo -n $name -q $query)
    rc=$?
    if [ $rc -ne 0 ]; then
        out=$(udevadm info --name=$name --query=$query)
        rc=$?
    fi
    if [ $rc -eq 0 ]; then
        echo $out
    fi
    return $rc
}

backup_file() {
    dir=$(dirname "$1")
    case $dir in /*);; *) die "unexpected non-absolute dir: $dir";; esac
    mkdir -p "$OVIRT_BACKUP_DIR/${dir:1}"
    test -f "$1" && cp -pf "$1" "$OVIRT_BACKUP_DIR/${dir:1}"
}

add_if_not_exist() {
    string="$1"
    file="$2"

    grep -qE "^[[:space:]]*$string($|#|[[:space:]])" "$file" \
        || echo "$string" >> "$file"
}

is_numeric() {
    printf "$1" | grep -q -E '^[0-9]+$'
}

# LVM2 tools wrapper
# to avoid warnings like:
# File descriptor 6 (pipe:[20637]) leaked on lvrename invocation.
# File descriptor 7 (pipe:[20637]) leaked on lvrename invocation.
lvrename() {
    /sbin/lvrename "$@" 6>&- 7>&-
}

pvs() {
    /sbin/pvs "$@" 6>&- 7>&-
}

pvcreate() {
    /sbin/pvcreate "$@" 6>&- 7>&-
}

pvremove() {
    /sbin/pvremove "$@" 6>&- 7>&-
}

vgcreate() {
    /sbin/vgcreate "$@" 6>&- 7>&-
}

vgremove() {
    /sbin/vgremove "$@" 6>&- 7>&-
}

lvcreate() {
    /sbin/lvcreate "$@" 6>&- 7>&-
}

lvremove() {
    /sbin/lvremove "$@" 6>&- 7>&-
}

# reboot wrapper
#   cleanup before reboot
reboot() {
    cd /
    # setup new Root if update is prepared
    if [ -e "/dev/disk/by-label/RootUpdate" ]; then
        root_update_dev=$(readlink -f /dev/disk/by-label/RootUpdate)
        root_dev=$(readlink -f /dev/disk/by-label/Root)
        e2label $root_dev RootBackup
        e2label $root_update_dev Root
    fi
    # run post-install hooks
    # e.g. to avoid reboot loops using Cobbler PXE only once
    # Cobbler XMLRPC post-install trigger (XXX is there cobbler SRV record?):
    # wget "http://192.168.50.2/cblr/svc/op/trig/mode/post/system/$(hostname)"
    #   -O /dev/null
    for hook in $(ls /etc/ovirt-config-boot.d/* 2>/dev/null); do
        $hook
    done
    /sbin/reboot
}

# chkconfig_persist <servicename>
#   since symlinks cannot be persisted, replace symlinks with hardlinks and persist
chkconfig_persist() {
    local service=$1
    if [ -z "$service" ]; then
        return 1
    fi
    cd /etc/rc.d
    local to_persist=""
    for f in rc*.d/[S,K]??$service ; do
        local dir=$(dirname $f)
        local name=$(basename $f)
        cd $dir
        link=$(readlink $name)
        if [ -e "$link" ]; then
            rm -f $name
            ln $link $name
            to_persist="$to_persist /etc/rc.d/$f"
        fi
        cd ..
    done
    ovirt_store_config $to_persist
}

# Asks a yes or no question. Accepts Y/N/A so users can abort.
# RC=0 - Y/y entered
# RC=1 - N/n entered
# RC=2 - A/a entered
# $1 - the prompt to use
# $2 - require a response (def. true)
# $3 - allow aborting (def. false)
ask_yes_or_no () {
    local prompt=${1}
    local required=${2-true}
    local allow_abort=${3-false}

    while true; do
        read -ep "${prompt} "
        case $REPLY in
            Y|y) return 0;;
            N|n) return 1;;
            A|a) if $allow_abort; then return 2; fi ;;
            *)
                if [ $required == false ]; then
                    return 99
                fi
                ;;
        esac
    done
}

# Verifies the address entered is a valid IPv4 address.
is_valid_ipv4 () {
    local address=${1}
    local result=1

    if [[ "$address" =~ "^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$" ]]; then
        OIFS=$IFS
        IFS='.'
        ip=($address)
        IFS=$OIFS
        [[ ${ip[0]} -le 255 && ${ip[1]} -le 255 \
            && ${ip[2]} -le 255 && ${ip[3]} -le 255 ]]
        result=$?
    fi

    return $result
}

# Check if networking is already up
network_up () {
    ip addr show | grep -q "inet.*scope global"
}

# Cleans partition tables
wipe_partitions() {
    local drive=$1
    log "Wiping old boot sector"
    dd if=/dev/zero of=$drive bs=1024K count=1
    # zero out the GPT secondary header
    log "Wiping secondary gpt header"
    local disk_kb_count=$(sfdisk -s $drive 2>/dev/null)
    dd if=/dev/zero of=$drive bs=1024 seek=$(($disk_kb_count - 1)) count=1
}

test_ntp_configuration () {
    # stop ntpd service for testing
    service ntpd stop > /dev/null 2>&1
    SERVERS=$(echo $NTPSERVERS | awk 'BEGIN{FS=":"}{for (i=1; i<=NF; i++) print $i}')
        for server in $SERVERS; do
            ntpdate $server > /dev/null 2>&1
            result=$?
            if [ $result -ne 0 ]; then
                printf "\n Unable to verify NTP server: $server \n"
            else
                printf "\n Verified NTP server: $server \n"
            fi
        done
    service ntpd start

}

get_dm_device ()
{
    local device=$1
    local return_var=$2
    major=$(stat -c '%t' $(readlink -f $device))
    minor=$(stat -c '%T' $(readlink -f $device))
    local dm_device=
    local rc=1
    for dm in /dev/mapper/*; do
        if [ $major = $(stat -c '%t' $dm) -a \
            $minor = $(stat -c '%T' $dm) ]; then
            local dm_device=$dm
            rc=0
            break
        fi
    done

    eval $return_var=$dm_device

    return $rc
}

# execute a function if called as a script, e.g.
#   ovirt-functions ovirt_store_config /etc/hosts

if [ "$(basename "$0")" = "ovirt-functions" ]; then
    "$@"
fi
