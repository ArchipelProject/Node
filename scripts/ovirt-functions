# -*-Shell-script-*-

OVIRT_LOGFILE=/var/log/ovirt.log
TEE="tee -a $OVIRT_LOGFILE"
_log_status=1

# label of the oVirt partition
OVIRT_LABEL=OVIRT
# configuration defaults
OVIRT_DEFAULTS=/etc/default/ovirt
if [ -f $OVIRT_DEFAULTS ]; then
    . $OVIRT_DEFAULTS
fi
# fallback when default is empty
OVIRT_STANDALONE=${OVIRT_STANDALONE:-0}

OVIRT_BACKUP_DIR=/var/lib/ovirt-backup

OVIRT_CONFIG_FILES="\
 /etc/sysconfig/network-scripts/ifcfg-*         \
 /etc/rsyslog.conf                              \
 /etc/libvirt/libvirtd.conf                     \
 /etc/sasl2/libvirt.conf                        \
 /etc/libvirt/passwd.db                         \
 /etc/passwd                                    \
 /etc/shadow                                    \
 /etc/ssh/ssh_host*_key*                        \
 /etc/default/ovirt                             \
 /etc/sysconfig/network                         \
 /etc/collectd.conf                             \
 /etc/logrotate.d/ovirt-logrotate.conf
"

# Save stdout to fd 6 and stderr to fd 7.  Redirect normal stdout/stderr
# to log file
start_log() {
    if [ "$_log_status" = 1 ]; then
        exec 6>&1
        exec 7>&2
        exec 1>>$OVIRT_LOGFILE
        exec 2>&1
        _log_status=0
    fi
}

# Restore stdout/stderr from fd 6 and 7, respectively.  Close fd 6 and 7
stop_log() {
    if [ "$_log_status" != 1 ]; then
        exec 1>&6 6>&-
        exec 2>&7 7>&-
        _log_status=1
    fi
}

log() {
    printf "$(date +'%b %d %H:%M:%S') "

    if [ "$_log_status" = 1 ]; then
        echo "$@"
    else
        echo "$@" >&6
    fi
}

ovirt_store_firstboot_config() {
    # persist config for standalone
    ovirt_store_config $OVIRT_CONFIG_FILES
}

# return 1 if oVirt Node is running in standalone mode
# return 0 if oVirt Node is managed by the oVirt Server
is_managed() {
    return $OVIRT_STANDALONE
}

# oVirt Node in standalone mode does not try to contact the oVirt Server
is_standalone() {
    if is_managed; then return 1; else return 0; fi
}

# perform automatic local disk installation
# when at least following boot parameters are present:
# for networking - OVIRT_BOOTIF, management NIC
#       if other ip bootparams are not specified, IPv4 DHCP is assumed
# for storage - OVIRT_INIT, local disk to use
#       if ovirt_vol is not specified, default volume sizes are set
is_auto_install() {
    if [ -n "$OVIRT_BOOTIF" -a -n "$OVIRT_INIT" ] ; then
        return 0
    else
        return 1
    fi
}

# was firstboot menu already shown?
# state is stored in persistent config partition
is_firstboot() {
    if [ -z "$OVIRT_FIRSTBOOT" -o "$OVIRT_FIRSTBOOT" = "1" ]; then
        return 0
    else
        return 1
    fi
}

disable_firstboot() {
    if mount_config; then
        augtool <<EOF
set /files$OVIRT_DEFAULTS/OVIRT_FIRSTBOOT no
EOF
    fi
}

# find_srv SERVICE PROTO
#
# reads DNS SRV record
# sets SRV_HOST and SRV_PORT if DNS SRV record found, clears them if not
# Example usage:
# find_srv ovirt tcp
# if [ -n "$SRV_HOST" -a -n "$SRV_PORT" ]; then
#   echo "oVirt Server found"
# else
#   echo "no oVirt Server available, running standalone"
# fi
find_srv()
{
    local dnsreply
    dnsreply=$(dig +short -t srv _$1._$2.$(dnsdomainname))
    if [ $? -eq 0 ]; then
        set _ $dnsreply; shift
        SRV_HOST=$4; SRV_PORT=$3
    else
        SRV_HOST=; SRV_PORT=
    fi
}

die()
{
    echo "$@" 1>&2; failure; echo 1>&2; exit 1
}

ovirt_setup_libvirtd() {
    # just to get a boot warning to shut up
    touch /etc/resolv.conf

    # make libvirtd listen on the external interfaces
    sed -i -e 's/^#\(LIBVIRTD_ARGS="--listen"\).*/\1/' \
       /etc/sysconfig/libvirtd

    # set up qemu daemon to allow outside VNC connections
    sed -i -e 's/^[[:space:]]*#[[:space:]]*\(vnc_listen = "0.0.0.0"\).*/\1/' \
       /etc/libvirt/qemu.conf
    # set up libvirtd to listen on TCP (for kerberos)
    sed -i -e "s/^[[:space:]]*#[[:space:]]*\(listen_tcp\)\>.*/\1 = 1/" \
       -e "s/^[[:space:]]*#[[:space:]]*\(listen_tls\)\>.*/\1 = 0/" \
       /etc/libvirt/libvirtd.conf

    # with libvirt (0.4.0), make sure we we setup gssapi in the mech_list
    sasl_conf=/etc/sasl2/libvirt.conf
    if ! grep -qE "^mech_list: gssapi" $sasl_conf ; then
       sed -i -e "s/^\([[:space:]]*mech_list.*\)/#\1/" $sasl_conf
       echo "mech_list: gssapi" >> $sasl_conf
    fi
}

md5() {
  md5sum $1 2>/dev/null | (read MD5 filename; echo $MD5)
}

# return uppercase value
uc() {
    echo $(echo $1|tr '[[:lower:]]' '[[:upper:]]')
}

# return indirect value
# non-bashism for ${!var}
ptr() {
    local v=$1
    eval "v=\$$v"
    echo $v
}

# mount livecd media
# e.g. CD /dev/sr0, USB /dev/sda1,
# PXE /dev/loop0 (loopback ISO)
# not available when booted from local disk installation
mount_live() {
    if grep -q " /live " /proc/mounts; then
        return 0
    fi
    local live_dev=/dev/live
    if [ ! -e $live_dev ]; then
      # PXE boot
      live_dev=/dev/loop0
    fi
    mkdir -p /live
    mount -r $live_dev /live || mount $live_dev /live
}

# mount boot partition
# boot loader + kernel + initrd
mount_boot() {
    if grep -q " /boot " /proc/mounts; then
        return 0
    fi
    mkdir -p /boot
    mount /dev/disk/by-label/BOOT /boot
}

# mount liveos partition
# LiveOS/
mount_liveos() {
    if grep -q " /liveos " /proc/mounts; then
        return 0
    fi
    mkdir -p /liveos
    mount /dev/HostVG/Root /liveos
}

# mount config partition
# /config for persistance
mount_config() {
    if ! grep -q " /config " /proc/mounts; then
        mkdir -p /config
        mount /dev/HostVG/Config /config
    fi

    if grep -q " /config " /proc/mounts; then
        # optional config embedded in the livecd image
        if [ -e /live/config ]; then
            cp -rv --update /live/config/* /config
        fi
        # bind mount all persisted configs to rootfs
        for f in $(find /config -type f); do
            target=${f#/config}
            if grep -q " $target " /proc/mounts ; then
                # skip if already bind-mounted
                true
            else
                mkdir -p "$(dirname $target)"
                touch "$target"
                mount -n --bind $f "$target"
            fi
        done
    else
        # /config is not available
        return 1
    fi
}

# mount logging partition
mount_logging() {
    if grep -q "/dev/mapper/HostVG-Logging " /proc/mounts; then
        return 0
    fi

    if [ -e /dev/HostVG/Logging ] ; then
        log "Mounting log partition"
        #  backup the logs
        if [ -e /var/log.bak ]; then
            rm -rf /var/log.bak
        fi
        cp -av /var/log /var/log.bak

        mount /dev/HostVG/Logging /var/log
        cp -av /var/log.bak/* /var/log
        restorecon -rv /var/log
        rm -Rf /var/log.bak
        service rsyslog restart

        return 0
    else
        # /var/log is not available
        printf "\nThe logging partion has not been created. Please create it at the main menu.\n"
        return 1
    fi
}

# mount data partition
mount_data() {
    if grep -q "/dev/mapper/HostVG-Data " /proc/mounts; then
        return 0
    fi

    if [ -e /dev/HostVG/Data ] ; then
        mkdir -p /data
        mount /data
        mkdir -p /data/images
        mount /var/lib/libvirt/images
        restorecon -rv /var/lib/libvirt/images

        return 0
    else
        # /data is not available
        printf "\nThe data partion has not been created. Please create it at the main menu.\n"
        return 1
    fi
}

# augtool wrapper
#   workaround for bind-mounted files
#   see https://fedorahosted.org/augeas/ticket/32
# augtool [tmpaugscript]
# script MUST NOT include save, it is added by the wrapper
# with copy_if_rename_fails flag set
# 'tmpaugscript' is removed after successfull execution
# without a parameter, augtool commands are expected on standard input
augtool() {
    local tmpaug=$1
    if [ -z "$1" ]; then
        # read from stdin
        tmpaug=$(mktemp)
        cat > $tmpaug
    fi
    cat >> $tmpaug <<EOF
clear /augeas/save/copy_if_rename_fails
save
EOF
    /usr/bin/augtool < $tmpaug > /dev/null
    rc=$?
    if [ $rc -eq 0 ]; then
        rm $tmpaug
    fi
    return $rc
}

# persist configuration to /config
#   ovirt_store_config /etc/config /etc/config2 ...
#   copy to /config and bind-mount back
ovirt_store_config() {
    if grep -q " /config " /proc/mounts; then
        printf "storing to /config :\n"
        for f in "$@"; do
            printf "$f"
            # skip if file does not exist
            if [ ! -e $f ]; then
                printf " Skipping, file does not exist\n"
                continue
            fi
            # skip if already bind-mounted
            if grep -q " $f " /proc/mounts ; then
                printf " Skipping, file already persisted\n"
            else
                mkdir -p /config$(dirname $f)
                cp -a $f /config$f \
                && mount -n --bind /config$f $f \
                || printf " Failed to persist\n"
                printf " File persisted\n"
            fi
            # register in /config/files used by rc.sysinit
            if ! grep -q "^$f$" /config/files 2> /dev/null ; then
                printf "$f\n" >> /config/files
            fi
        done
        echo
    else
        printf "warning: persistent config storage not available\n"
    fi
}

# compat function to handle different udev versions
udev_info() {
    local name=$1
    local query=$2
    local out

    # old udev command with shortopts
    out=$(udevinfo -n $name -q $query)
    rc=$?
    if [ $rc -ne 0 ]; then
        out=$(udevadm info --name=$name --query=$query)
        rc=$?
    fi
    if [ $rc -eq 0 ]; then
        echo $out
    fi
    return $rc
}

backup_file() {
    dir=$(dirname "$1")
    case $dir in /*);; *) die "unexpected non-absolute dir: $dir";; esac
    mkdir -p "$OVIRT_BACKUP_DIR/${dir:1}"
    test -f "$1" && cp -pf "$1" "$OVIRT_BACKUP_DIR/${dir:1}"
}

add_if_not_exist() {
    string="$1"
    file="$2"

    grep -qE "^[[:space:]]*$string($|#|[[:space:]])" "$file" \
        || echo "$string" >> "$file"
}

is_numeric() {
    printf "$1" | grep -q -E '^[0-9]+$'
}
